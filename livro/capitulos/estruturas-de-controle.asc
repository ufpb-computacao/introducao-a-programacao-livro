[[estrutura_controle]]
== Estruturas de Controle 

.Objetivos do capítulo
____________________
Ao final deste capítulo você deverá ser capaz de:

* Entender as estruturas sequenciais, de seleção e de repetição;
* Escrever estruturas de seleção utilizando os comandos if, if-else e switch 
da linguagem C; 
* Escrever estruturas de repetição utilizando os comandos for, while e 
do-while da linguagem C.
____________________

////
TODO - REV.01: Sugestão de melhoria para análise pelo autor 
Neste capítulo é importante refletir o que realmente pretendemos ensinar para o aluno.
Aqui vejo dois conteúdos distintos um é a discussão sobre as estruturas algorítmicas
e um outro seria o ensino da linguagem C para programação. Pelo que se lê
a intenção é ensinar algoritmos usando a linguagem C como padrão, contudo,
seria aconselhável nesse caso termos algo que introduza o que é uma linguagem de programação
e suas respectivas características falando um pouco mais da linguagem C. A partir daí
passaria a explanação do desenvolvimento de algoritmos utilizando como base essa
linguagem, inclusive na finalizaçaõ do capítulo de Algoritmos é dito isso. 
A transição do conteúdo do capítulo anterior para esse não está suave para 
o aluno. 
////

=== Introdução

Vimos no <<algoritimos>> que os algoritmos são instruções que contém passos para 
solucionar um determinado problema. Vimos também que estes algoritmos podem 
ser representados através de linguagens de programação, como por exemplo, a 
linguagem C, que estamos aprendendo aqui. Estes passos são executados na 
sequência que eles aparecem. Entretanto, em muitas situações, é necessário 
alterar o fluxo de execução destas instruções. Pode ser que seja necessário 
executar um passo, ou um conjunto deles, apenas se uma determinada condição `for` 
verdadeira, ou talvez, pode ser que seja preciso repetir um conjunto de passos várias vezes 
até uma determinada condição. Neste sentido, este capítulo irá explicar as 
diferentes estruturas de controle existentes nos algoritmos e seus respectivos 
comandos na linguagem C.

=== Estrutura Sequencial

Um algoritmo que possui uma estrutura sequencial significa que suas 
instruções são executadas na sequência em que elas aparecem, sem nenhuma 
alteração no seu fluxo, a não ser, claro, que exista alguma instrução 
explícita para a mudança deste fluxo. Vejamos o código em C na 
<<estrutura_sequencial>> abaixo.

[[estrutura_sequencial]]
.Estrutura sequencial na linguagem C
image::images/estruturas-de-controle/sequencia.eps[scaledwidth="40%"]

Este algoritmo irá ler dois valores e guardá-los, respectivamente, nas 
variáveis `x` e `y`. Após isso, a variável inteira 'soma' receberá a soma dos 
valores de `x` e `y`. Em seguida, será mostrada na saída padrão, o resultado 
desta soma. Perceba que os passos do algoritmo são executados de cima para 
baixo.

Entretanto, em alguns momentos os problemas que queremos resolver requerem a 
alteração no fluxo normal de execução do algoritmo. Na próxima seção, 
iremos aprender como executar um conjunto de instruções de acordo com uma determinada 
condição.

=== Estrutura de Decisão
Como foi dito, muitas vezes é necessário criar blocos de instruções no 
algoritmo que são executados apenas se uma determinada condição `for` 
verdadeira. Veja o algoritmo abaixo:

 "Se hoje não chover, então João irá à praia".

No algoritmo acima, João irá à praia se, e somente se, não chover hoje. 
Significa que esta instrução de João ir à praia só será executada se a 
condição de não chover for verdadeira. Este tipo de estrutura é chamado de 
*estrutura de decisão*, também conhecido como estrutura de seleção ou 
condicional.

Podemos ter três tipos de estrutura de decisão: decisão simples, decisão 
composta e decisão múltipla. Vamos ver adiante estes três tipos e quais são 
os comandos na linguagem C, respectivamente, para cada um destes tipos.

////
TODO - REV.02: Sugestão de melhoria para análise pelo autor 
Senti muito falta de gráficos e/ou diagramas nas explicações que seguem.
O conteúdo pode ser bem representado usando os fluxogramas que auxiliam
o entendimento das estruturas de controle. Será que não seria interessante
ilustrar com esse tipo de gráfico?
////

==== Decisão simples
(((Se)))

Quando queremos que uma determinada instrução ou um conjunto de instruções 
execute apenas se uma determinada condição for verdadeira. A estrutura da 
decisão simples é a seguinte:

 SE condição ENTÃO instrução

Uma condição deve ter como resultado apenas dois valores possíveis: 
verdadeiro ou falso. A instrução só será executada se a condição tiver o 
valor verdadeiro.

////
TODO - REV.03: Sugestão de melhoria para análise pelo autor 
Seria possível na explicação que segue referenciar o número da linha
de código onde os comandos aparecem? Ficaria mais claro para o aluno.
Sugeriria que todo código tivesse número de linha, isso ajudaria
a referenciar durante a explicação.
////

Vamos analisar o exemplo a seguir. Este algoritmo lê um valor digitado pelo 
usuário e armazena na variável `x`. Em seguida, o comando `SE` verifica se o 
valor de `x` é menor que `20`. Caso seja, a instrução `ESCREVA` é executada, 
mostrando na tela a frase "o valor de X é menor que 20".

(((LEIA)))(((ESCREVA)))

[[alg_menorq20]]
.Algoritmo que comparava valor lido com 20
============
 LEIA x
 SE x < 20 ENTÃO 
 ESCREVA "O valor de x é menor que 20."
============

Para cada linguagem de programação há uma sintaxe para criar estruturas de 
controle. Na Linguagem C, a estrutura de decisão simples possui a seguinte 
forma: 

[source, c]
----
 if (expressão) 
     instrução;
----


Na linguagem C, a condição é definida como uma expressão, que pode ser 
lógica ou aritmética. Ao ser executada, a expressão é verificada. Se o 
resultado desta for verdadeiro, a instrução que vem após a expressão é 
executada. 

Entretanto, muitas vezes queremos que mais de uma instrução seja executada 
caso a condição seja verdadeira. Neste caso, devemos utilizar um bloco de 
instruções dentro do comando *if*, como é mostrado abaixo. 

(((if)))

.Estrutura de decisão simples com blocos na linguagem C
[source, c]
----
 if (expressão) {
     instrução 1;
     instrução 2;
     ...
 }
----

As duas formas, com e sem bloco, se diferenciam apenas pelo fato de que a 
primeira possui apenas uma instrução a ser executada caso a condição seja 
verdadeira. No segundo caso, um bloco de instruções será executado. Na 
linguagem C, um bloco de instruções deve estar entre chaves.

[IMPORTANT]
Sempre que você precisar executar um bloco de instruções, utilize as chaves 
para delimitar o início e o fim deste bloco.  

////
FIXME - REV.04: Possível erro para análise pelo autor 
No parágrafo seguinte se menciona que as expressões aritméticas foram vistas
no capítulo 2, mas o cap 2 é o capítulo corrente não?  
////

Como foi dito, a expressão pode conter uma expressão lógica ou aritmética. 
As expressões aritméticas foram vistas no capítulo 2. Vamos ver agora como 
funcionam as expressões lógicas na linguagem C.


// FIXME adicionar link para o capítulo 2 no paragrafo acima.

===== Expressões lógicas

(((Expressões lógicas)))

////
TODO - REV.05: Sugestão de melhoria para análise pelo autor 
Seria interessante deixar claro que são os operandos e o operador 
em uma expressão lógica. 
////

As expressões lógicas são usualmente utilizadas para fazer comparações 
entre operandos. Para isso, estas expressões são compostas por operadores 
lógicos e relacionais, e possuem apenas dois valores possíveis: verdadeiro ou 
falso. Por exemplo, quando queremos saber se um valor é maior, menor, igual ou 
diferente de um outro valor.

Na linguagem C, os seguintes operadores relacionais podem ser utilizados:

[width="50%",cols="^1,^1",options="header"]
|========================
| Operador | Descrição
| `>`        | Maior que
| `<`        | Menor que
| `>=`       | Maior ou igual a
| `<=`       | Menor ou igual a
| `==`       | Igual a
| `!=`       | Diferente de
|========================
	
Considere o código <<menorq20>> abaixo. Este reflete o mesmo algoritmo de <<alg_menorq20>>, 
sendo que agora, implementado na linguagem C. Na linha 6, estamos pedindo para 
o usuário entrar com o valor de `x`. Na linha 8, temos um comando `if`, onde há 
uma expressão relacional `x < 20`. Portanto, essa expressão é verificada e caso 
seja verdadeira, será mostrado na saída padrão "O valor de x é menor que a 
20." (linha 9). Caso a expressão seja falsa, o algoritmo se encerra sem mostrar 
nada na saída padrão, pois a instrução após o comando `if` não é executada. 

////
TODO - REV.06: Sugestão de melhoria para análise pelo autor 
Seria interessante representar esse algoritmo em c também usando
o fluxograma, isso daria ao aluno uma visão mais clara do condicional 
e o que seria executado dependendo do resultado da expressfão lógica. 
////

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/menorq20.c[code/estruturas-de-controle/menorq20.c]

[[menorq20]]
[source, c, numbered]
.menorq20.c
----
include::code/estruturas-de-controle/menorq20.c[]
----

Em outros casos, necessitamos utilizar operadores lógicos nas expressões para 
avaliar mais de uma expressão relacional. Por exemplo, digamos que no problema 
acima queremos verificar se o valor digitado para a variável `x` está dentro do 
intervalo entre `10` *e* `20`. Neste caso, precisamos que a condição verifique as 
duas expressões relacionais: `(x > 10)` *e* `(x < 20)`. Portanto, precisamos 
conectar as duas expressões relacionais utilizando um operador lógico `E`. A 
tabela abaixo apresenta os operadores lógicos possíveis:

////
TODO - REV.07: Sugestão de melhoria para análise pelo autor 
O quadro apresentado a seguir parece confuso. Na verdade,
ele apresenta o operador na linguagem C e diz como descrição o equivalente
em linguagem algoritmica (LA). Sugeriria fazer o inverso e adicionar uma 
melhor explicação do que é cada operador, por exemplo, na 1a
coluna seria o operador em LA, em seguida fornecer uma descrição mais 
explicativa, e depois apresentar a sintaxe equivalente na linguagem C. 

////

(((E))) (((Ou))) (((Não)))

[width="50%",cols="^1,^1",options="header"]
|========================
| Operador em C | Operador em linguagem algorítmica
| &&       | E
| \|\|     | OU
| !        | NÃO
|========================

Portanto, o algoritmo para resolver o problema acima, na linguagem C, é o 
seguinte:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/[code/estruturas-de-controle/entre10e20.c]

[source, c, numbered]
.entre10e20.c
----
include::code/estruturas-de-controle/entre10e20.c[]
----

Perceba que agora a condição do comando `if` possui duas expressões 
relacionais conectadas por um operador lógico `E` (`&&`). Nesse caso, se ambas as 
expressões forem verdadeiras, será mostrada na saída padrão "x esta' entre 
10 e 20". Caso alguma das expressões seja falsa, nada será mostrado, pois o 
resultado da expressão completa é falso. Vejamos a tabela abaixo, denominada de tabela verdade,
que mostra a relação lógica entre duas expressões e seus respectivos resultados.

////
TODO - REV.09: Sugestão de melhoria para análise pelo autor 
Sugeriria dividir o quadro que segue em três, isso deixaria o texto mais
legível para o leitor. 
Seria interessante falar que os operadores tem precedência e como
fazer para alterá-la de forma explícita.
////

[cols="^1,^1m,^1,^1",options="header"]
|========================
|Expressão 1|Operador|Expressão 2|Resultado
|Verdadeiro|E|Verdadeiro|Verdadeiro
|Verdadeiro|E|Falso|Falso
|Falso|E|Falso|Falso
|Verdadeiro|OU|Verdadeiro|Verdadeiro
|Verdadeiro|OU|Falso|Verdadeiro
|Falso|OU|Falso|Falso
|Verdadeiro|NÃO|-|Falso
|Falso|NÃO|-|Verdadeiro
|========================

////
TODO - REV.10: Sugestão de melhoria para análise pelo autor 
Considerando os exercícios resolvidos, nesse ponto o leitor sabe o que é uma variável? Sabe o que é uma atribuição de valor?
Acredito não ter ficado claro até o momento esses pontos básicos da programação. 
Não seria interessante ter falado um pouco sobre isso antes?
////

===== Exercício resolvido
*ER 3.1.* Considere quatro variáveis `a`, `b`, `c` e `d` com valores iniciais de 5, 7, 3 
e 9. Dada as condições abaixo, indique se o resultado final da expressão 
será verdadeiro ou falso.

a. `(a != 3 || b < 10 || c == 5)`
b. `(d > 8 && c == 3 || a >=10)`
c. `!(d == 12 && a != 10)`
d. `(c == 4 || d <= 6) && (a >= 5 && b != 9) || (!(a < 5))`

Resposta:

a. Neste caso temos três expressões lógicas. A primeira `(a != 3)` é 
verdadeira. A segunda `(b < 10)` é verdadeira, e a terceira `(c == 5)` é falsa. 
Como as expressões estão conectadas por um operador OU (`||`), então basta que 
uma das expressões seja verdadeira para o resultado da expressão completa ser 
verdadeira. 
b. Temos neste caso três expressões. Para um melhor entendimento, vamos 
utilizar uma tabela. As duas primeiras expressões `(d > 8 e c == 3)` são verdadeiras
e estão conectadas pelo operador lógico `&&`, logo `R1 && R2` é verdadeiro. 
A terceira expressão `(a >= 10)`, por sua vez, é falsa. Então, resolvendo `R3 || R4`, 
temos o resultado final como verdadeiro.
+
[format="csv",cols="^1,^1,^1",options="header"]
|====
Rs, Expressão,	Resultado
R1,	`d > 8`,	VERDADEIRO
R2,	`c == 3`,	VERDADEIRO
R3,	`R1 && R2`,	VERDADEIRO
R4,	`a >= 10`,	FALSO
R5,	`R3 || R4`,	VERDADEIRO
|====

c. Utilizando novamente a tabela, temos que a primeira expressão `(d == 12)` é 
falsa. A segunda expressão `(a != 10)` verdadeira. A relação entre `R1 && R2` 
é falsa, pois apenas `R2` é verdadeira. A última expressão é uma negação 
de `R3`, ou seja, se `R3` é falso, então `R4` é verdadeiro.
+
[format="csv",cols="^1,^2,^3",options="header"]
|====
R,	Expressão,	Resultado
R1,	`d == 12`,	FALSO
R2,	`a != 10`,	VERDADEIRO
R3,	`R1  && R2`,	FALSO
R4,	`!R3`,	VERDADEIRO
|====

d. Vamos utilizar novamente a tabela para nos auxiliar. Temos que prestar 
bastante atenção nos parênteses das expressões que podem ser utilizadas 
para explicitar a precedência da avaliação. 
+
[format="csv",cols="^1,^2,^3",options="header"]
|====
Rs,	Expressão,	Resultado
R1,	`c == 4`,	FALSO
R2,	`d <= 6`,	FALSO
R3,	`R1 || R2`,	FALSO
R4,	`a >= 5`,	VERDADEIRO
R5,	`b != 9`,	VERDADEIRO
R6,	`R4 && R5`,	VERDADEIRO
R7,	`a < 5`,	FALSO
R8,	`!R7`,	VERDADEIRO
R9,	`R3 && R6`,	FALSO
R10,	`R9 || R8`,	VERDADEIRO
|====


===== Verificação da condição com expressões aritméticas na Linguagem C

(((if)))

Anteriormente, dissemos que a expressão dentro de um comando `if` pode ser 
lógica ou aritmética. Vimos como funciona nos casos de expressões lógicas. 
Nos casos de expressões aritméticas, na linguagem C, 'Falso' assume o valor 
zero, e 'Verdadeiro' assume qualquer valor diferente de zero.  Neste sentido, 
quando utilizamos uma expressão aritmética dentro da condição de um comando 
`if` para verificar se esta é verdadeira ou falsa, temos que ter o cuidado de 
analisar o valor resultante. Vamos verificar o exemplo no código abaixo.

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/if5.c[code/estruturas-de-controle/if5.c]

[source, c, numbered]
.if5.c
----
include::code/estruturas-de-controle/if5.c[]
----

Inicialmente a variável inteira `x` recebe o valor `5` (linha 4). Na linha 6 existe uma 
estrutura de decisão simples, onde há a verificação da expressão que está entre parênteses.
Nesse caso, a expressão é apenas a própria variável `x`, logo o resultado da expressão é 
o valor desta, que é `5`. Considerando o que foi dito, quando o resultado for 
*diferente de zero*, ele é considerado *verdadeiro*. Logo, o resultado da 
expressão também é verdadeiro, e então a instrução que vem após a condição é executada.

Já na linha 9, também há outra estrutura de decisão simples, na qual a 
condição a ser avaliada é a expressão `x - 5`. O resultado dessa expressão é *zero*, fazendo com
seja avaliada como *falsa*. Consequentemente, a instrução que vem após a condição não é executada.

==== Decisão composta 
(((if-else)))

////
FIXME - REV.11: Possível erro para análise pelo autor 
Rever a frase: "...momentos, ao termos uma estrutura...". 
////

Em alguns momentos, ao termos uma estrutura de decisão, queremos que uma outra 
instrução ou um outro bloco de instruções seja executado caso a condição 
de decisão seja falsa. Esta estrutura é chamada de decisão composta.

O pseudocódigo abaixo exemplifica uma estrutura de decisão composta. 

////
TODO - REV.12: Sugestão de melhoria para análise pelo autor 
Sugeriria adicionar também um gráfico em fluxograma exemplificando
a decisão composta. 
////

[[alg_decisao_composta]]
.Pseudocódigo com decisão composta
=====================
 LEIA nota
 SE nota >= 7 ENTÃO 
   ESCREVA "Aprovado"
 SENÃO
   ESCREVA "Reprovado"
=====================

Na linguagem C, utilizamos a palavra `else`, após a instrução ou bloco de 
instruções do `if`, para definir que queremos executar um outro conjunto de 
instruções, caso a expressão condicional seja falsa. 

////
TODO - REV.13: Sugestão de melhoria para análise pelo autor 
Sugeriria adicionar um quadro em que apresentasse o comando equivalente em C. 
////

[source, c]
----
 if (expressão) 
   instrução 1;
 else 
   instrução 2;
----

////
TODO - REV.14: Sugestão de melhoria para análise pelo autor 
Sugeriria adicionar lembretes em seções do tipo "Atenção!" ou "Importante!" reforçando
algumas particularidades da linguagem C. Por exemplo, toda instrução precisa ser terminada
com ";" e coisas assim.
////

Quando possuímos apenas uma instrução a ser executada, não precisamos 
utilizar o delimitador de bloco de instruções (as chaves). Neste caso, a 
condição é verificada. Caso seja positiva, a instrução 1 é executada, 
caso contrário, a instrução 2 é executada. Caso queiramos que um conjunto 
de instruções seja executado, devemos utilizar então as chaves, como mostra 
o código abaixo.

////
TODO - REV.15: Sugestão de melhoria para análise pelo autor 
Sugeriria representar o mesmo código também usando o fluxograma.
////

[source, c]
----
 if (condição) {
   instrução 1;
   instrução 2;
   ...
 } else {
   instrução 3;
   instrução 4;
   ...
 }
----

Neste caso temos dois blocos de instruções: um para o bloco do `if`, que será 
executado caso a condição seja verdadeira, e o bloco de instruções do `else`, 
caso a condição seja falsa.

(((indentação)))

IMPORTANT: Tabule as instruções que estão dentro dos blocos, colocando-os mais a 
direita (utilize a tecla TAB do teclado). Esta organização do código 
chama-se *indentação*. Dessa maneira, seu código se torna mais legível, e 
consequentemente mais fácil de encontrar possíveis erros. 

Vamos traduzir o pseudocódigo apresentado no <<alg_decisao_composta>> para a linguagem C.

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/nota7.c[code/estruturas-de-controle/nota7.c]


[source, c, numbered]
.nota7.c
----
include::code/estruturas-de-controle/nota7.c[]
----

===== Exercício resolvido

////
TODO - REV.16: Sugestão de melhoria para análise pelo autor 
Sugeriria adicionar pelo menos mais dois exercícios resolvidos.
Outro ponto para refletir em relação aos exercícios é a sintaxe
de programação da linguagem C, será que os alunos tem
amadurecimento para fazer o código como apresentado no 
exemplo, entender & e etc? Particularmente, estou achando 
que com o que eles conhecem até o momento não conseguiriam fazer.
////

*ER 3.2.* Escreva um programa para ler 2 números inteiros do teclado (A e B), 
verificar e imprimir qual deles é o maior, ou a mensagem "A=B", caso sejam 
iguais.

Resposta:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/comparaab.c[code/estruturas-de-controle/comparaab.c]


[source, c, numbered]
.comparaab.c
----
include::code/estruturas-de-controle/comparaab.c[]
----

==== Comando de decisão múltipla
(((switch)))

////
TODO - REV.17: Sugestão de melhoria para análise pelo autor 
Aqui já se fala direto no comando equivalente em C para o comando
escolha da linguagem algoritmica, isso deixa um pouco confuso o capítulo
em termos de conteúdo. É preciso estabelecer uma coerência para auxiliar o leitor
no entendimento do assunto que é considerado dificil por boa parte dos alunos.
////

Uma outra forma de escrever uma estrutura de condição é utilizando o comando 
de decisão múltipla `switch`. Este tipo de estrutura condicional tem a mesma 
função do `if-else-if`, com a diferença que o comando `switch` não aceita 
expressões, apenas constantes. A vantagem de se utilizar este comando é a 
legibilidade do código quando conhecemos os possíveis valores para uma 
determinada variável. Vamos ver o formato de uso do comando `switch`. 


[source, c]
----
 switch (variável) {
    case VALOR1: 
      instruçao1;
      instrução2;
      break;
    case VALOR2: 
      instruçao3;
      instrução4;
      break;
    default: 
      instruçao5;
      instrução6;
      break;
 }
----

Uma variável do tipo `char` ou `int` é colocada entre parênteses após o comando 
`switch`. Os valores desta variável que serão avaliados logo em seguida, através 
das declarações `case`. Para cada possível valor da variável, existe uma 
declaração `case` correspondente. Caso o valor seja aquele que corresponde na 
declaração `case`, então as instruções abaixo dela serão executadas até 
encontrar o comando `break`. A declaração `default` é opcional, e é executada 
apenas se a variável não for igual a nenhuma das constantes definidas nas 
declarações `case`.	

IMPORTANT: O comando `break` tem a função de interromper um determinado fluxo de 
execução. Este comando será melhor explicado na seção 3.4.5 que fala sobre 
os comandos de desvio. O importante a saber por hora é que o comando `break` 
deve ser utilizado ao final das instruções de cada declaração `case`. Caso 
não seja colocado, as instruções das outras declarações `case` também 
serão executadas.

//FIXME corrigir seção acima

////
TODO - REV.18: Sugestão de melhoria para análise pelo autor 
Nada foi falado sobre tipos de variáveis possiveis. Sugeriria 
mais uma vez que o código C apresentado fosse representado também
usando gráficos (fluxograma). Precisamos ser o mais didático possível,
principalmente, considerando essa parte introdutória da programação!
////

Para um melhor entendimento, vamos analisar o código <<semana_c>> abaixo. A ideia deste 
programa é que o usuário digite o valor numérico correspondente ao dia da 
semana e o programa mostre por extenso este dia. Uma variável chamada `semana` 
do tipo `int` é declarada (linha 4) e guardará o valor que o usuário irá 
digitar (linha 7). Em seguida, o comando `switch` foi utilizado (linha 9). Para 
cada dia da semana existe uma declaração `case` correspondente. Isto significa 
que se o usuário digitou o valor 1, a instrução da linha 11 será executada, mostrando 
na saída a string "Domingo". Caso o valor digitado seja 2, a instrução da linha 14 é 
executada, mostrando na saída a string "Segunda-feira". A mesma ideia acontece 
para os outros 5 dias da semana. Caso o valor digitado pelo usuário não esteja 
entre 1 e 7, as instruções da declaração `default` serão executadas, mostrando a 
string "Numero fora do intervalo permitido.".

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/semana.c[code/estruturas-de-controle/semana.c]


[[semana_c]]
[source, c, numbered]
.semana.c
----
include::code/estruturas-de-controle/semana.c[]
----

=== Estrutura de Repetição

(((Enquanto)))

Considere um algoritmo em que você precise repetir um determinado conjunto de 
passos, por exemplo, um algoritmo para retirar uma lâmpada do bocal. Um passo 
deste algoritmo é realizar um movimento com a mão para girar a lâmpada. Este 
passo deve ser repetido até que a lâmpada desencaixe do bocal. Neste sentido, 
existem as estruturas de repetições nas linguagens de programação para 
permitir que uma instrução ou um bloco de instruções seja repetido em um 
algoritmo computacional. Estas estruturas também são conhecidas como 
estruturas de iteração ou estruturas de laço.

Vamos tomar como base <<alg_decisao_composta>>, onde uma nota é solicitada ao 
usuário. Caso a nota seja maior que 7, é mostrado ``Aprovado'' na tela, caso 
contrário, é mostrado "Reprovado". O algoritmo utilizado, até então, só 
permite que uma nota seja digitada, ou seja, quando o usuário digita a nota, 
o programa apresenta o resultado e em seguida fecha. Mas digamos que agora 
queremos que o programa continue executando, solicitando notas e apresentando o 
resultado, até que o usuário digite o valor -1 para sair do programa.
Este algoritmo é mostrado no pseudocódigo abaixo. Perceba 
que temos uma condição `nota <> -1` que será avaliada antes de executar as 
instruções que estão dentro do bloco do `ENQUANTO`. Desse modo, enquanto a nota 
digitada pelo usuário for diferente de `-1`, o programa irá solicitar uma nota 
e apresentar o resultado.

////
TODO - REV.19: Sugestão de melhoria para análise pelo autor 
Sugeriria adicionar a forma gráfica para apoiar ainda mais a explicação.
////

[[alg_estrutura_repeticao]]
.Pseudocódigo com estrutura de repetição
========================
 LEIA nota
 ENQUANTO nota <> -1 FAÇA
   SE nota >= 7 ENTÃO
     ESCREVA "Aprovado"
   SENÃO
     ESCREVA "Reprovado"
     
   LEIA nota  
 FIM-ENQUANTO 
========================

Na linguagem C há três opções diferentes para se criar estruturas de 
repetição. São os comandos `while`, `do-while` e `for`. Veremos cada um deles em 
detalhes a seguir.

==== Comando while
(((while)))

Podemos usar o comando `while` quando desejamos que uma ou mais instruções 
sejam repetidas até que uma determinada condição seja atendida. A estrutura 
do `while` na linguagem C é bastante parecida com a do pseudocódigo apresentado
anteriormente. Veja abaixo:

[source, c]
----
 while (expressão) {
   instrução 1;
   instrução 2;
   ...
 }
----

As instruções serão executadas repetidamente enquanto a expressão for 
verdadeira. Assim que essa condição tornar-se falsa, o laço para. Vejamos o 
exemplo abaixo, que consiste no pseudocódigo do <<alg_estrutura_repeticao>>
escrito na linguagem C.

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/whilenota.c[code/estruturas-de-controle/whilenota.c]


[source, c, numbered]
.whilenota.c
----
include::code/estruturas-de-controle/whilenota.c[]
----

Vamos tentar entender o código acima. Inicialmente, uma variável `nota`, do tipo `float`, 
é declarada (linha 4). Logo depois ocorre a leitura da primeira nota.
Caso ela seja diferente de `-1`, o bloco de instruções dentro do `while` (linhas 8 a 14)
será executado. O comando `while` fará com que as instruções em seu corpo sejam executadas,
repetidamente, enquanto a condição `nota != -1` for verdadeira.

Vejamos outro exemplo. O programa <<mostrado10vezes>> abaixo escreve 10 vezes na tela "Isto sera' 
mostrado 10 vezes.". A condição de parada do comando `while` é `cont <= 10`, o que 
significa que enquanto o valor de `cont` for menor ou igual a `10`, o bloco de 
instruções será executado. Para que o laço tenha fim, a variável `cont` precisa ser incrementada
até que alcance o valor `11`.

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/mostrado10vezes.c[code/estruturas-de-controle/mostrado10vezes.c]

[[mostrado10vezes]]
[source, c, numbered]
.mostrado10vezes.c
----
include::code/estruturas-de-controle/mostrado10vezes.c[]
----

===== Exercício resolvido

*ER 3.3*: Escreva um programa que leia várias notas de alunos de uma turma. O 
programa deve ler notas até que o usuário digite o valor `-1`. Após isso, o 
programa deve mostrar a média dessas notas.

Resposta:

Neste programa não sabemos previamente a quantidade de notas que o usuário 
precisa. Precisamos, nesse caso, utilizar um laço de repetição que fique 
lendo notas até que o valor `-1` seja passado pelo usuário. Desse modo, podemos 
utilizar o comando `while` (linha 7) com a condição de parada `nota != -1`, ou seja,
o usuário seguirá entrando com as notas enquanto os valores digitados forem 
diferentes de `-1`. Dentro do laço, é solicitado que o usuário digite a nota (linha 8).
Na linha 9, o valor digitado pelo usuário é armazenado na variável `nota`.
Para calcular a média das notas, precisamos de 
duas informações: a soma de todas as notas e a quantidade de notas lidas. 
Utilizamos a variável `soma` para armazenar a soma das notas (linha 12) e a
variável `cont` para armazenar a quantidade de notas (linha 13). A média 
das notas será mostrada depois do laço, ou seja, quando o usuário digitar `-1` 
para a nota. Como o cálculo da média precisa da quantidade total das notas, seu
cálculo e o comando para sua exibição devem ser executados após o término do laço (linha 17).

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/notas_alunos_c.c[code/estruturas-de-controle/notas_alunos_c.c]


[[notas_alunos_c]]
[source, c, numbered]
.notas_alunos.c
----
include::code/estruturas-de-controle/notas_alunos.c[]
----
////
TODO - REV.22: Sugestão de melhoria para análise pelo autor 
Sugeriria adicionar, pelo menos, mais um exercício resolvido e
comentado.
////

==== Comando do-while

(((do-while)))


Assim como o `while`, o comando `do-while` também é uma estrutura de repetição.
Com semelhanças que vão além dos seus nomes, sobretudo em termos de funcionalidade,
a principal diferença entre eles é que, no caso do `do-while`, o bloco de instruções 
dentro do laço é executado pelo menos uma vez, mesmo que a condição seja 
falsa. Isso acontece porque a condição de parada só é avaliada depois que 
as instruções são executadas. Segue abaixo a estrutura do comando `do-while`.

[source, c]
----
 do {
    instrução 1;
    instrução 2;
    ...

 } while (condição);
----

O comando começa com a palavra `do`, seguida do bloco de instruções a ser 
repetido. Após a execução dessas instruções, a condição é avaliada. 
Caso seja verdadeira, as instruções são executadas novamente, caso 
contrário, o laço se encerra. Para entender melhor, observe o exemplo abaixo. 
Este exemplo faz exatamente o mesmo que o exemplo <<mostrado10vezes>>, porém, utilizando 
o comando `do-while`.

////
FIXME: faz exatamente o mesmo que o exemplo anterior... qual anterior?
////

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/do_while.c[code/estruturas-de-controle/do_while.c]

[[do_while_c]]
[source, c, numbered]
.do_while.c
----
include::code/estruturas-de-controle/do_while.c[]
----

==== Comando for
(((for)))

Este comando também serve para criar um laço de repetição e geralmente é 
utilizado quando conhecemos a quantidade de vezes que queremos que as 
instruções sejam repetidas. 

O formato do comando `for` é o seguinte:

[source, c]
----
 for (expressão1; condição; expressão2) {
    instrução1;
    instrução2;
    ...
 }
----

////
TODO - REV.23: Sugestão de melhoria para análise pelo autor 
Sugeriria explicar melhor o que é um incremento e o que é um decremento. 
Normalmente, o aluno tem uma certa dificuldade em entender a primeira vista
esses conceitos.
////

Em `expressão1`, uma variável, geralmente um contador, recebe um valor inicial. 
Essa variável será incrementada ou decrementada de acordo com a expressão 
definida em `expressão2`. O laço ficará executando as instruções 
(`instrução1` e `instrução2`) até que a `condição` seja falsa. 

Vejamos o exemplo abaixo para entender a sequência de operações que são realizadas
durante a execução do comando `for`. O programa <<for_cont>> abaixo tem o mesmo 
resultado de <<do_while_c>> mostrado anteriormente. Inicialmete, uma variável inteira é 
declarada (linha 4). 
Diferentemente do programa <<do_while_c>>, não atribuímos nenhum valor inicial à variável, 
visto que ela será inicializada na primeira expressão do comando `for`. Na linha 6 
existe um comando `for`, cuja primeira expressão é a inicialização da variável `cont`. 
Em seguida, a condição `cont <= 10` é avaliada. Como inicialmente `cont = 0`, 
expressão é avaliada como verdadeira, e a instrução na linha 7 é executada. No fim da 
execução das instruções (nesse caso, especificamente, há apenas uma instrução) contidas 
dentro do `for`, a terceira expressão do `for` 
é avaliada, que nesse caso é um incremento `(cont++)`. Então a variável `cont` 
é incrementada e passa a valer `2`. Em seguida, a condição é verificada 
novamente e, caso seja verdadeira, executa novamente a instrução dentro do 
`for`. Essa sequência de passos é repetida até que a condição seja avaliada como falsa.

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/for_cont.c[code/estruturas-de-controle/for_cont.c]

[[for_cont]]
[source, c, numbered]
.for_cont.c
----
include::code/estruturas-de-controle/for_cont.c[]
----

Para entender melhor o funcionamento do comando `for`, vamos ver outro exemplo 
que utiliza decremento (`--`) ao invés do incremento. A ideia é muito parecida com a do 
exemplo anterior, entretanto, ao invés de incremento, temos um 
decremento da variável `cont`. No comando `for`, a variável `cont` é inicializada 
com o valor `10`. Em seguida, a condição `cont > 0` é avaliada. Como o valor de 
`cont` é `10`, a condição é verdadeira, e a instrução dentro do `for` é 
executada (linha 7). Ao fim da execução dessa instrução, a variável `cont` 
é decrementada e passa a valer `9`. Novamente a condição `cont >` 0 é 
verificada e continua sendo verdadeira, o que faz com que a instrução da 
linha 7 seja executada novamente. O laço continua até a variável `cont` 
passar a valer `0`, caso no qual a condição `cont > 0` será falsa.

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/for_cont_decremento.c[code/estruturas-de-controle/for_cont_decremento.c]

[source, c, numbered]
.for_cont_decremento.c
----
include::code/estruturas-de-controle/for_cont_decremento.c[]
----

Uma particularidade do comando `for` é que nenhum dos três elementos que o compõe é 
obrigatório, ou seja, podemos omitir qualquer um desses elementos ou até mesmo
uma combinação deles. Contudo, essa é uma prática que deve ser evitada.


==== Laço infinito

(((Laço infinito)))

Quando a condição de parada de uma determinada estrutura de repetição nunca 
é alcançada, as intruções do laço são executadas indefinidamente, e consequentemente
o programa nunca chega ao seu fim. Tal comportamento é algo que deve ser evitado
em programação (na grande maioria das situações) e, por ser um problema tão recorrente,
recebe um nome especial: laço infinito. O exemplo abaixo ilustra esse tipo de laço:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/laco_infinito.c[code/estruturas-de-controle/laco_infinito.c]

[source, c, numbered]
.laco_infinito.c
----
include::code/estruturas-de-controle/laco_infinito.c[]
----

Observe que na linha 6 temos um comando `for` cuja condição de parada não 
foi definida. Consequentemente, o laço entra em loop e a 
execução da instrução na linha 7 é executada indefinidamente.

WARNING: Ao criar uma estrutura de repetição, observe bem a condição de parada 
para verificar se ela realmente será alcançada em algum momento. Sem esse cuidado
você corre o risco de criar um laço infinito, e seu programa, possivelmente, não 
terá o resultado esperado. 

==== Exercício Resolvido
*E.R 3.4.* Analise o programa abaixo. O objetivo do programa é ler 50 valores e 
mostrar, ao final da leitura, o menor deles. Entretanto, ele possui um problema. 
Identifique e corrija o erro.

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/menor_deles.c[code/estruturas-de-controle/menor_deles.c]

[source, c, numbered]
.menor_deles.c
----
include::code/estruturas-de-controle/menor_deles.c[]
----

Resposta:

Vamos analisar o código considerando seu objetivo: ler 50 valores e apresentar 
o menor deles. Vamos iniciar nossa análise na estrutura de repetição `while`, 
na linha 10. A condição é `quantidade < 50`.  Logo percebemos que a variável 
`quantidade`, que tem o valor inicial de `1` na sua declaração, não é alterada 
em nenhum momento dentro do laço, o que sugere algum problema. Para o laço 
ter um fim, é necessário que a variável `quantidade` atinja o valor `50` em 
algum momento, e não é isso que está acontecendo. Portanto, temos um laço 
infinito. Para corrigir o problema, devemos incluir uma linha dentro do laço
a fim de incrementar o valor da variável `quantidade`. 

O código abaixo apresenta a solução do problema com a inclusão da linha 12, 
na qual a variável `quantidade` é incrementada. Dessa forma, o laço deixou de ser 
infinito, uma vez que ele atingirá o valor `50` em algum momento, tornando 
falsa a condição `quantidade < 50` do laço.

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/menor_deles_resposta.c[code/estruturas-de-controle/menor_deles_resposta.c]

[source, c, numbered]
.menor_deles_resposta.c
----
include::code/estruturas-de-controle/menor_deles_resposta.c[]
----

==== Comandos de desvio

Vimos no último exemplo o que é um laço infinito. Em alguns momentos, 
precisamos utilizar um comando para realizar um desvio dentro do laço de 
repetição. Esses comandos são: `break` e `continue`. Ambos podem ser utilizados 
em qualquer estrutura da repetição. 

===== Comando break

(((break)))

O comando `break` interrompe a execução do laço, fazendo com que as 
instruções dentro do laço após esse comando não sejam executadas. Vamos 
ver o exemplo <<break_interrompe>>. Apesar de não haver condição de parada 
no `for`, ele irá parar quando o comando `break` for executado, ou seja, quando 
o valor da variável `cont` for igual a `10`. Caso houvesse mais alguma outra 
instrução após a linha 8, dentro do bloco de instruções do `for`, ela não seria
executada.

////
TODO - REV.28: Sugestão de melhoria para análise pelo autor 
Sugeriria exemplificar também de forma gráfica ou com animação.
////

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/break_interrompe.c[code/estruturas-de-controle/break_interrompe.c]

[[break_interrompe]]
[source, c, numbered]
.break_interrompe.c
----
include::code/estruturas-de-controle/break_interrompe.c[]
----


===== Comando continue
(((continue)))

O comando `continue` faz com que o fluxo de execução ``salte'' para a avaliação da 
condição de parada do laço, no caso do `while` e `do-while`, e para a expressão 
de incremento e decremento, no caso do comando `for`. Isso significa que as 
instruções após esse comando não são executadas.

Agora vamos analisar o programa <<continue_desvio>> abaixo. Esse programa mostra na tela os 
números ímpares no intervalo de 1 a 20. A variável `cont` é inicializada com 
o valor `1` no `for`. Como a condição é verdadeira, as instruções dentro do 
bloco são executadas. Agora atenção para o comando `if` (linha 7). Na 
condição do `if`, há uma expressão `cont % 2 == 0`, o que significa que se o 
resto da divisão inteira entre a variável `cont` e `2` for `0`, o comando 
`continue` é executado. Entretanto, o resto da divisão será `1`. Nesse caso, a 
a instrução da linha 8 é executada, mostrando o valor `1` na saída.
Em seguida, a expressão de incremento do `for` é 
avaliada, e `cont` passa a valer `2`. Como `cont` ainda é menor ou igual a `20`, as 
instruções do bloco são executadas novamente. Mais uma vez, na linha 6, a 
condição do `if` é avaliada. Todavia, o resto da divisão de `cont` e `2` agora é 
igual a `0`, e então a instrução `continue` é executada. Com sua execução, o fluxo de
volta para o `for`, e a expressão de incremento é avaliada. Note que a instrução da linha 7,
nesse caso, não será mais executada. O valor de `cont` então é incrementado para `3`, 
repetindo o que foi explicado quando `cont` era igual a `1`. 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/estruturas-de-controle/continue_desvio.c[code/estruturas-de-controle/continue_desvio.c]

[[continue_desvio]]
[source, c, numbered]
.continue_desvio.c
----
include::code/estruturas-de-controle/continue_desvio.c[]
----


=== Recapitulando

Este capítulo apresentou as estruturas de controle da linguagem C e como 
elas podem ser utilizadas.

A estrutura sequencial significa que o fluxo de execução das instruções 
segue uma linha sequencial, que no caso da linguagem C, é de cima para baixo
e da esquerda para a direita.Entretanto, podemos mudar o fluxo de execução 
desas instruções utilizando as estruturas de decisão e de repetição.
No caso da estrutura de decisão, aprendemos a utilizar os comandos `if`,
`else` e `switch` para executar uma instrução ou um bloco de instruções caso
uma determinada condição seja verdadeira. 

Aprendemos também a construir laços de repetição com os comandos `while`, 
`do-while` e `for`. Vimos que todos esses comandos proporcionam a repetição de 
instruções até que uma determinada condição seja falsa. Diante disso, é 
importante ter bastante atenção na condição de parada dessas estruturas de 
repetição, para não criar um laço infinito.

No próximo capítulo estudaremos os arranjos: uma estrutura de dados que
tem o objetivo de representar um conjunto de valores do mesmo tipo. Vamos também aprender a 
manipular as cadeias de caracteres, também conhecidas como strings.

////
TODO - REV.31: Sugestão de melhoria para análise pelo autor 
De uma maneira geral, acho que o que foi explicado até o momento
não é o suficiente para os alunos sozinhos resolverem os exercícios propostos.
Precisamos ser mais ilustrativos, mais explicativos e didáticos. Apesar de parecer
redundante algumas explicações, o aluno EAD precisa de um material que lhe
dê um maior apoio a aprendizagem.

Não há curiosidades, links para outras informações que poderíamos estar
adicionando aqui para despertar maior interesse do aluno pelo assunto?
////

=== Exercícios Propostos
1. Escreva um programa que verifique se um número digitado pelo usuário é 
menor, igual ou maior que zero.
2. Dado o algoritmo abaixo, explique o que acontece se o valor lido para a 
variável `x` for: `3`, `1` e `0`. Explique o porquê.
+
[source, c]
----
#include <stdio.h>

int main() {
  int x;
  
  scanf(&x);
  if (x) printf("verdadeiro");
  
  return 0;
}
----

3. Escreva um programa que informe se um dado ano é ou não bissexto. Obs.: um 
ano é bissexto se ele for divisível por 400 ou se ele for divisível por 4 e 
não por 100.
4. Escreva um programa que mostre todos os números pares no intervalo de 1 a 
40 de forma decrescente, utilizando o comando `while`. Depois faça o mesmo, mas 
desta vez, utilizando o comando `for`.
5. Um determinado banco abriu uma linha de crédito para os funcionários 
públicos. Porém, o valor máximo da prestação não poderá ultrapassar 30% 
do salário deste funcionário. Faça um programa para ajudar este banco. O 
programa deve permitir o usuário entrar com o salário do funcionário e o 
valor da prestação e informar se o empréstimo pode ou não ser concedido.
6. Escreva um programa que leia o mês do ano em valor numérico e exiba este 
mês por extenso (utilize o comando `switch`).
7. Faça três programas que mostrem de 1 a 10 na tela, utilizando, em cada um, 
uma estrutura de laço de repetição diferente. 
8. Escreva um programa que mostre na tela os números múltiplos de 3 no 
intervalo de 2 a 100.
9. Escreva um programa para ler dois números inteiros M e N e, a seguir, 
imprimir os números pares existentes no intervalo [M, N]. 
10. A organização de um evento esportivo deseja um programa que faça a 
leitura do nome e a pontuação de cada um dos 10 participantes e exiba o nome 
do vencedor. Elabore este programa.
11. O supermercado Excelente Preço está precisando ser informatizado. Neste 
sentido, o dono quer um programa que leia os preços dos produtos até que seja 
informado o valor zero. No final o programa deve informar o total da compra e 
perguntar a forma de pagamento. As opções da forma de pagamento são: 1) A 
vista; 2) No cartão de crédito. Se a opção escolhida for a vista, então o 
programa informa o valor da compra com um desconto de 5%. Caso a compra seja no 
cartão de crédito, o programa informa o valor da compra dividido em 4 vezes.




// Sempre termine os arquivos com uma linha em branco.


